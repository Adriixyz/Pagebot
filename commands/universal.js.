const axios = require('axios');

// API URLs
const apiUrlGpt4 = 'https://deku-rest-api-ywad.onrender.com/gpt4';
const apiUrlPinterest = 'https://deku-rest-api-ywad.onrender.com/api/pinterest';
const apiUrlLyrics = 'https://deku-rest-api-ywad.onrender.com/search/lyrics';
const apiUrlSpotify = 'https://deku-rest-api-ywad.onrender.com/spotify';
const apiUrlImagen = 'https://imagen-9n6s.onrender.com/generate-image';

module.exports = {
  name: 'universal',
  description: 'Process user input and route to the appropriate API',
  author: 'Deku & Adrian',
  role: 1,
  async execute(senderId, args, pageAccessToken, sendMessage) {
    const input = args.join(' ').toLowerCase();

    if (checkPinterest(input)) {
      await sendMessage(senderId, { text: 'Please wait while we process your request...' }, pageAccessToken);
      await handlePinterest(senderId, args, pageAccessToken, sendMessage);
    } else if (checkLyrics(input)) {
      await sendMessage(senderId, { text: 'Please wait while we process your request...' }, pageAccessToken);
      await handleLyrics(senderId, input, pageAccessToken, sendMessage);
    } else if (checkSpotify(input)) {
      await sendMessage(senderId, { text: 'Please wait while we process your request...' }, pageAccessToken);
      await handleSpotify(senderId, args, pageAccessToken, sendMessage);
    } else if (checkImagen(input)) {
      await sendMessage(senderId, { text: 'Please wait while we process your request...' }, pageAccessToken);
      await handleImagen(senderId, args, pageAccessToken, sendMessage);
    } else {
      // No specific command found, default to GPT-4
      await handleGpt4(senderId, args, pageAccessToken, sendMessage);
    }
  }
};

// Function to preprocess lyrics query
function preprocessLyricsQuery(input) {
  return input.replace(/give me the lyrics of /i, '').trim();
}

// Function to check if input contains Pinterest-related keywords
function checkPinterest(input) {
  const pinterestKeywords = ['pinterest', 'picture', 'send me a picture', 'photo', 'photos', 'pictures'];
  return pinterestKeywords.some(keyword => input.includes(keyword));
}

// Function to check if input contains Lyrics-related keywords
function checkLyrics(input) {
  const lyricsKeywords = ['lyrics', 'give me the lyrics', 'lyrics of', 'lyrics for'];
  return lyricsKeywords.some(keyword => input.includes(keyword));
}

// Function to check if input contains Spotify-related keywords
function checkSpotify(input) {
  const spotifyKeywords = ['spotify', 'song', 'music', 'sing'];
  return spotifyKeywords.some(keyword => input.includes(keyword));
}

// Function to check if input contains Imagen-related keywords
function checkImagen(input) {
  const imagenKeywords = ['imagine', 'generate', 'generate an image of', 'image'];
  return imagenKeywords.some(keyword => input.includes(keyword));
}

// Handler for Pinterest API request
async function handlePinterest(senderId, args, pageAccessToken, sendMessage) {
  const query = args.join(' ');

  try {
    const response = await axios.get(apiUrlPinterest, {
      params: { q: query }
    });
    const images = response.data.result;

    if (images && images.length > 0) {
      for (const imageUrl of images) {
        const imageMessage = {
          attachment: {
            type: 'image',
            payload: {
              url: imageUrl,
              is_reusable: true
            }
          }
        };
        await sendMessage(senderId, imageMessage, pageAccessToken);
      }
    } else {
      await sendMessage(senderId, { text: 'No images found for your query.' }, pageAccessToken);
    }
  } catch (error) {
    console.error('Error fetching Pinterest images:', error);
    await sendMessage(senderId, { text: 'Sorry, there was an error processing your request.' }, pageAccessToken);
  }
}

// Handler for Lyrics API request
async function handleLyrics(senderId, input, pageAccessToken, sendMessage) {
  const query = preprocessLyricsQuery(input);
  try {
    const response = await axios.get(apiUrlLyrics, {
      params: { q: query }
    });
    const result = response.data.result;

    if (result && result.lyrics) {
      const lyricsMessage = `Title: ${result.title}\nArtist: ${result.artist}\n\n${result.lyrics}`;

      await sendResponseInChunks(senderId, lyricsMessage, pageAccessToken, sendMessage);

      if (result.image) {
        const imageMessage = {
          attachment: {
            type: 'image',
            payload: {
              url: result.image,
              is_reusable: true
            }
          }
        };
        await sendMessage(senderId, imageMessage, pageAccessToken);
      }
    } else {
      console.error('Error: No lyrics found in the response.');
      await sendMessage(senderId, { text: 'Sorry, no lyrics were found for your query.' }, pageAccessToken);
    }
  } catch (error) {
    console.error('Error calling Lyrics API:', error);
    await sendMessage(senderId, { text: 'Sorry, there was an error processing your request.' }, pageAccessToken);
  }
}

// Handler for Spotify API request
async function handleSpotify(senderId, args, pageAccessToken, sendMessage) {
  const query = args.join(' ');

  try {
    const response = await axios.get(apiUrlSpotify, {
      params: { q: query }
    });

    const spotifyLink = response.data.result;

    if (spotifyLink) {
      sendMessage(senderId, {
        attachment: {
          type: 'audio',
          payload: {
            url: spotifyLink,
            is_reusable: true
          }
        }
      }, pageAccessToken);
    } else {
      sendMessage(senderId, { text: 'Sorry, no Spotify link found for that query.' }, pageAccessToken);
    }
  } catch (error) {
    console.error('Error retrieving Spotify link:', error);
    sendMessage(senderId, { text: 'Sorry, there was an error processing your request.' }, pageAccessToken);
  }
}

// Handler for Imagen API request
async function handleImagen(senderId, args, pageAccessToken, sendMessage) {
  const prompt = args.join(' ');

  try {
    const response = await axios.get(apiUrlImagen, {
      params: { prompt }
    });
    const imageUrl = response.data.response;

    if (imageUrl) {
      const imageMessage = {
        attachment: {
          type: 'image',
          payload: {
            url: imageUrl,
            is_reusable: true
          }
        }
      };
      await sendMessage(senderId, imageMessage, pageAccessToken);
    } else {
      await sendMessage(senderId, { text: 'Sorry, I couldn\'t generate an image based on that prompt.' }, pageAccessToken);
    }
  } catch (error) {
    console.error('Error generating image:', error);
    await sendMessage(senderId, { text: 'Sorry, there was an error processing your request.' }, pageAccessToken);
  }
}

// Handler for GPT-4 API request
async function handleGpt4(senderId, args, pageAccessToken, sendMessage) {
  const prompt = args.join(' ');
  try {
    const response = await axios.get(apiUrlGpt4, {
      params: { prompt, uid: senderId }
    });
    let text = response.data.gpt4;

    // Remove initial 'Please wait...' message if present
    text = text.replace('Please wait while we process your request...', '');

    await sendResponseInChunks(senderId, text, pageAccessToken, sendMessage);
  } catch (error) {
    console.error('Error calling GPT-4 API:', error);
    await sendMessage(senderId, { text: 'Sorry, there was an error processing your request.' }, pageAccessToken);
  }
}

// Function to send response in chunks if necessary
async function sendResponseInChunks(senderId, text, pageAccessToken, sendMessage) {
  const maxMessageLength = 2000;
  if (text.length > maxMessageLength) {
    const messages = splitMessageIntoChunks(text, maxMessageLength);
    for (const message of messages) {
      await sendMessage(senderId, { text: message }, pageAccessToken);
    }
  } else {
    await sendMessage(senderId, { text }, pageAccessToken);
  }
}

// Function to split message into chunks
function splitMessageIntoChunks(message, chunkSize) {
  const chunks = [];
  let chunk = '';
  const words = message.split(' ');

  for (const word of words) {
    if ((chunk + word).length > chunkSize) {
      chunks.push(chunk.trim());
      chunk = '';
    }
    chunk += `${word} `;
  }

  if (chunk) {
    chunks.push(chunk.trim());
  }

  return chunks;
}